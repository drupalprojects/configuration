<?php
/**
 * @file
 * Tests for Configuration Management
 */

use Drupal\configuration\Config\Configuration;

/**
 * Base class for functional tests for configuration management.
 */
class ConfigurationWebTestCase extends DrupalWebTestCase {

  /**
   * Returns a new vocabulary with random properties.
   */
  protected function drupalCreateVocabulary($nodes) {
    // Create a vocabulary.
    $vocabulary = new stdClass();
    $vocabulary->name = $this->randomName();
    $vocabulary->description = $this->randomName();
    $vocabulary->machine_name = drupal_strtolower($this->randomName());
    $vocabulary->help = '';
    $vocabulary->nodes = array($nodes);
    $vocabulary->weight = mt_rand(0, 10);
    taxonomy_vocabulary_save($vocabulary);
    return $vocabulary;
  }

  /**
   * Implementation of DrupalWebTestCase::setUp().
   */
  public function setUp($modules = array()) {
    parent::setUp($modules);

    // Generate an unique path for this test based on the database prefix.
    $this->datastore_path = file_directory_temp();

    variable_set('configuration_config_path', $this->datastore_path);
    file_prepare_directory(variable_get('configuration_config_path', $this->datastore_path));
  }
}

class ConfigurationApiTest extends ConfigurationWebTestCase {

  /**
   * Test info.
   */
  public static function getInfo() {
    return array(
      'name' => t('Test Configuration API'),
      'description' => t('Test the import/export API'),
      'group' => t('Configuration'),
    );
  }

  /**
   * Set up test.
   */
  public function setUp() {
    parent::setUp(array(
      'configuration',
      'field',
      'filter',
      'image',
      'taxonomy',
    ));

    $this->content_type = $this->drupalCreateContentType();
    $nodes = array($this->content_type->type => $this->content_type->type);
    $this->vocabulary = $this->drupalCreateVocabulary($nodes);
    drupal_flush_all_caches();
  }

  public function testExportToDatastore() {

    // This will build the configuration and create the files in config://
    Configuration::exportToDataStore(array('content_type.' . $this->content_type->type));

    $files = array(
      'permission.delete_any_IDENTIFIER_content.inc',
      'permission.delete_own_IDENTIFIER_content.inc',
      'permission.edit_any_IDENTIFIER_content.inc',
      'permission.edit_own_IDENTIFIER_content.inc',
      'permission.create_IDENTIFIER_content.inc',
      'variable.comment_preview_IDENTIFIER.inc',
      'variable.comment_subject_field_IDENTIFIER.inc',
      'variable.comment_default_per_page_IDENTIFIER.inc',
      'variable.comment_form_location_IDENTIFIER.inc',
      'variable.node_submitted_IDENTIFIER.inc',
      'variable.node_options_IDENTIFIER.inc',
      'variable.node_preview_IDENTIFIER.inc',
      'variable.language_content_type_IDENTIFIER.inc',
      //'image_style.medium.inc',
      'variable.field_bundle_settings_node__IDENTIFIER.inc',
      //'image_style.large.inc',
      //'field.node.field_image.IDENTIFIER.inc',
      //'vocabulary.tags.inc',
      //'field.node.field_tags.IDENTIFIER.inc',
      'field.node.body.IDENTIFIER.inc',
      'content_type.IDENTIFIER.inc',
    );

    foreach ($files as $file) {
      $filename = str_replace('IDENTIFIER', $this->content_type->type, $file);
      $config_file_exists = file_exists($this->datastore_path . '/' . $filename);
      $this->assertTrue($config_file_exists, "Configuration file $filename was created.");
    }
  }
}
