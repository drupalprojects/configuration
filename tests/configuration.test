<?php
/**
 * @file
 * Tests for Configuration Management
 */

use Drupal\configuration\Config\Configuration;

/**
 * Base class for functional tests for configuration management.
 */
class ConfigurationWebTestCase extends DrupalWebTestCase {
  protected $profile = 'standard';

  /**
   * Returns a new vocabulary with random properties.
   */
  protected function drupalCreateVocabulary($nodes) {
    // Create a vocabulary.
    $vocabulary = new stdClass();
    $vocabulary->name = $this->randomName();
    $vocabulary->description = $this->randomName();
    $vocabulary->machine_name = drupal_strtolower($this->randomName());
    $vocabulary->help = '';
    $vocabulary->nodes = array($nodes);
    $vocabulary->weight = mt_rand(0, 10);
    taxonomy_vocabulary_save($vocabulary);
    return $vocabulary;
  }

  /**
   * Implementation of DrupalWebTestCase::setUp().
   */
  public function setUp($modules = array()) {
    parent::setUp($modules);

    // Generate an unique path for this test based on the database prefix.
    $this->datastore_path = file_directory_temp();

    variable_set('configuration_config_path', $this->datastore_path);
    $config_path = variable_get('configuration_config_path', $this->datastore_path);
    file_prepare_directory($config_path);
  }
}

class ConfigurationApiTest extends ConfigurationWebTestCase {

  protected $configurations;

  /**
   * Test info.
   */
  public static function getInfo() {
    return array(
      'name' => t('Test Configuration API'),
      'description' => t('Test the import/export API'),
      'group' => t('Configuration'),
    );
  }

  /**
   * Set up test.
   */
  public function setUp($modules = array()) {
    parent::setUp(array(
      'configuration',
      'field',
      'filter',
      'image',
      'taxonomy',
    ));

    $this->configurations = array(
      'variable.field_bundle_settings_node__article',
      'variable.language_content_type_article',
      'variable.node_options_article',
      'variable.node_preview_article',
      'variable.node_submitted_article',
      'variable.comment_default_per_page_article',
      'variable.comment_form_location_article',
      'variable.comment_preview_article',
      'variable.comment_subject_field_article',
      'content_type.article',
      'field.node.body.article',
      'vocabulary.tags',
      'field.node.field_tags.article',
      'image_style.large',
      'image_style.medium',
      'field.node.field_image.article',
      'permission.create_article_content',
      'permission.edit_own_article_content',
      'permission.edit_any_article_content',
      'permission.delete_own_article_content',
      'permission.delete_any_article_content',
    );

  }

  public function testExportToDatastore() {
    $results = Configuration::exportToDataStore(array('content_type.article'));
    $exported = $results->getInfo('exported');

    foreach ($this->configurations as $config) {
      $this->assertTrue(in_array($config, $exported), "Configuration for $config was exported.");
    }

    $count_tracked = db_query("SELECT COUNT(component) FROM {configuration_staging}")->fetchField();
    $this->assertTrue(empty($count_tracked), "No configurations have been tracked.");
  }

  public function testStartAndStopTracking() {
    $results = Configuration::startTracking(array('content_type.article'));
    $exported = $results->getInfo('exported');

    $count_tracked = db_query("SELECT COUNT(component) FROM {configuration_staging}")->fetchField();
    $this->assertTrue($count_tracked == count($exported), t("@num of @total configurations have been tracked.", array('@num' => $count_tracked, '@total' => count($exported))));

    $results = Configuration::stopTracking(array('content_type.article'));
    $count_tracked = db_query("SELECT COUNT(component) FROM {configuration_staging}")->fetchField();
    $this->assertTrue(empty($count_tracked), "No configurations have been tracked.");
  }

  public function testRevertActiveStore() {
    $results = Configuration::startTracking(array('content_type.article'));
    $exported = $results->getInfo('exported');

    $handler = Configuration::getConfigurationHandler('content_type');

    $content_types = node_type_get_types();
    $article = $content_types['article'];
    $article->description = 'modified';
    node_type_save($article);

    $modified_config = new $handler('article');
    $original_config = new $handler('article');
    $original_config->loadFromStaging();
    $modified_config->loadFromActiveStore();

    $this->assertTrue($original_config->getHash() != $modified_config->getHash(), "Hash for content type Article has changed after modify the content type.");

    $results = Configuration::revertActiveStore(array('content_type.article'));
    $modified_config->loadFromActiveStore();

    $this->assertTrue($original_config->getHash() == $modified_config->getHash(), "Configuration for content type Article has been reverted.");
  }
}
