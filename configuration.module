<?php

/**
 * @file
 * API for Configuration Management module.
 */

/**
 * A bit flag used to let us know if a configuration is the same in both the
 * activestore and the datastore.
 */
define('CONFIGURATION_IN_SYNC', 0x0000);

/**
 * A bit flag used to let us know if a configuration was overridden as a result
 * of changing the activestore directly. (config changes via the UI)
 */
define('CONFIGURATION_ACTIVESTORE_OVERRIDDEN', 0x0001);

/**
 * A bit flag used to let us know if a configuration is not currently being
 * tracked.
 */
define('CONFIGURATION_ACTIVESTORE_ONLY', 0X0200);

/**
 * A bit flag used to let us know if a configuration is only in the datastore.
 */
define('CONFIGURATION_DATASTORE_ONLY', 0x0008);

/**
 * A bit flag used to let us know if a configuration needs to be rebuilded.
 */
define('CONFIGURATION_NEEDS_REBUILD', 0x0010);

/**
 * A bit flag used to let us know if a module for the configuration is not
 * available to install in the site.
 */
define('CONFIGURATION_MODULE_MISSING', 0x0100);

/**
 * A bit flag used to let us know if a module for the configuration is disabled
 * but can be enabled.
 */
define('CONFIGURATION_MODULE_TO_INSTALL', 0x0101);

/**
 * A bit flag used to let us know if a module for the configuration is installed.
 */
define('CONFIGURATION_MODULE_INSTALLED', 0x0102);

use Drupal\configuration\Config\Configuration;

/**
 * Implements hook_stream_wrappers().
 */
function configuration_stream_wrappers() {
  return array(
    'config' => array(
      'name' => t('Configuration files'),
      'class' => 'ConfigurationStreamWrapper',
      'description' => t('Configuration files export directory.'),
      'type' => STREAM_WRAPPERS_LOCAL_HIDDEN,
    ),
  );
}

/**
 * Implements hook_configuration_handlers().
 */
function configuration_configuration_handlers() {
  $handlers = array(
    'content_type' => '\Drupal\configuration\Config\ContentTypeConfiguration',
    'field'        => '\Drupal\configuration\Config\FieldConfiguration',
    'image_style'  => '\Drupal\configuration\Config\ImageStyleConfiguration',
    'text_format'  => '\Drupal\configuration\Config\TextFormatConfiguration',
    'variable'     => '\Drupal\configuration\Config\VariableConfiguration',
    'permission'   => '\Drupal\configuration\Config\PermissionConfiguration',
    'vocabulary'   => '\Drupal\configuration\Config\VocabularyConfiguration',
    'menu'         => '\Drupal\configuration\Config\MenuConfiguration',
    'menu_link'    => '\Drupal\configuration\Config\MenuLinkConfiguration',
    'ctools'       => '\Drupal\configuration\Config\CtoolsConfiguration',
    'views'        => '\Drupal\configuration\Config\ViewConfiguration',
    'page_manager' => '\Drupal\configuration\Config\PageManagerHandlerConfiguration',
    'wysiwyg'      => '\Drupal\configuration\Config\WysiwygConfiguration',
  );

  return $handlers;
}

/**
 * Backup a configuration into the staging area.
 *
 * @param $component
 *   The name of the component to backup, i.e, 'content_type',
 *   'field', 'variable', 'permission', etc.
 * @param $identifier
 *   The identifier of the configuration. Some examples:
 *   For $component == 'content_type', $identifier = 'article'
 *   For $component == 'field', $identifier 'node.article.field_image'
 *   For $component == 'variable', $identifier = 'comment_controls_article'
 */
function configuration_backup_to_staging($component, $identifier, $backup_dependencies = TRUE, $backup_optionals = TRUE) {
  $configuration = Configuration::createConfigurationInstance($component . '.' . $identifier);
  $backuped = array();
  $configuration->backupConfiguration($backuped, $backup_dependencies, $backup_optionals);
  return $backuped;
}

/**
 * Returns a list of components that can be exported.
 */
function configuration_get_handlers() {
  return Configuration::getAllConfigurationHandlers();
}

/**
 * Load a list of configurations from config:// into the staging area.
 */
function configuration_load_configurations($list = array()) {
  $handlers = configuration_get_handlers();
  $components = array();
  foreach ($handlers as $handler) {
    $class = '\\' . $handler['namespace'] . '\\' . $handler['handler'];
    $components = array_merge($components, $class::scanDataStore());
  }
  $to_load = Configuration::importConfigurations($components, $list, TRUE, TRUE, FALSE);
  foreach ($to_load as $config) {
    $config->saveToStaging();
  }
}

/**
 * Import all configuration files within a directory.
 *
 * @param $path
 *   The path to the directory to import.
 * @param $enable_modules
 *   Enable all the required modules before the import process.
 *
 */
function configuration_import_directory($path, $enable_modules = TRUE) {
  Configuration::setStream($path);

  $file_content = drupal_substr(file_get_contents($path . 'configurations.inc'), 6);
  // this line creates a $configurations array with a list of components.
  @eval($file_content);

  if ($enable_modules) {
    $settings = Configuration::discoverRequiredModules($configurations);
    $missing = $settings->getInfo('modules_missing');
    if (count($missing)) {
      $missing = implode(', ', $missing);
      drupal_set_message(t('The following modules are required to import the specified configurations but are not available to install: %modules', array('%modules' => $missing)), 'error');
      return FALSE;
    }
    else {
      $to_install = $settings->getInfo('modules_to_install');
      module_enable($to_install);
    }
  }

  $result = Configuration::importToActiveStore($configurations);
  $imported = $result->getInfo('imported');
  if (is_array($imported) && count($imported) > 0) {
    return $imported;
  }
  else {
    return FALSE;
  }
}
